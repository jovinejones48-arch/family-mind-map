<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Interactive Family Tree</title>
<style>
    body {
        margin: 0;
        font-family: Arial, sans-serif;
        background: #bdbdbd;
        overflow: hidden;
    }
    svg {
        width: 100vw;
        height: 100vh;
    }
    .link {
        stroke: #333;
        stroke-width: 2;
    }
    .node text {
        fill: black;
        font-weight: bold;
        pointer-events: none;
        font-size: 14px;
        text-anchor: middle;
        dominant-baseline: middle;
    }
    .node circle {
        fill: #fff;
        stroke: #000;
        stroke-width: 2;
    }
    .node rect {
        fill: #e3f2fd;
        stroke: #000;
        stroke-width: 2;
        rx: 10;
        ry: 10;
    }
    .node polygon {
        fill: #fff3e0;
        stroke: #000;
        stroke-width: 2;
    }
</style>
</head>
<body>
<svg></svg>
<script>
const svg = document.querySelector("svg");
const width = window.innerWidth;
const height = window.innerHeight;

// Family members - easy to edit
const people = [
    { id: 1, name: "Adam", shape: "circle", generation: 1 },
    { id: 2, name: "Eve", shape: "circle", generation: 1 },
    { id: 3, name: "John", shape: "rect", generation: 2 },
    { id: 4, name: "Mary", shape: "rect", generation: 2 },
    { id: 5, name: "Paul", shape: "diamond", generation: 3 }
];

// Relationships - easy to edit
const links = [
    { from: 1, to: 3 },
    { from: 2, to: 3 },
    { from: 1, to: 4 },
    { from: 2, to: 4 },
    { from: 3, to: 5 },
    { from: 4, to: 5 }
];

// initialize positions
people.forEach(p => {
    p.x = Math.random() * width;
    p.y = Math.random() * height;
    p.vx = 0;
    p.vy = 0;
});

function getPerson(id) { return people.find(p => p.id === id); }

// create links
const linkElems = links.map(l => {
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("class","link");
    svg.appendChild(line);
    return { line, from: getPerson(l.from), to: getPerson(l.to) };
});

// create nodes
const nodeElems = people.map(p => {
    const g = document.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute("class","node");
    g.style.cursor = "pointer";

    let shape;
    if(p.shape==="circle") shape = document.createElementNS("http://www.w3.org/2000/svg","circle");
    if(p.shape==="rect") shape = document.createElementNS("http://www.w3.org/2000/svg","rect");
    if(p.shape==="diamond") shape = document.createElementNS("http://www.w3.org/2000/svg","polygon");

    if(p.shape==="circle") shape.setAttribute("r",30);
    if(p.shape==="rect") { shape.setAttribute("width",100); shape.setAttribute("height",50); shape.setAttribute("x",-50); shape.setAttribute("y",-25); }
    if(p.shape==="diamond") shape.setAttribute("points","0,-35 50,0 0,35 -50,0");

    const text = document.createElementNS("http://www.w3.org/2000/svg","text");
    text.textContent = p.name;

    g.appendChild(shape);
    g.appendChild(text);
    svg.appendChild(g);

    makeDraggable(g,p);

    return { g, p };
});

// update positions (force-directed)
function update() {
    const k = 0.1;
    people.forEach(p=>{
        links.forEach(l=>{
            let source = getPerson(l.from);
            let target = getPerson(l.to);
            let dx = target.x - source.x;
            let dy = target.y - source.y;
            let dist = Math.sqrt(dx*dx+dy*dy) || 1;
            let force = (dist-150)*k;
            let fx = force * dx/dist;
            let fy = force * dy/dist;
            if(p===source){ p.vx+=fx; p.vy+=fy; }
            if(p===target){ p.vx-=fx; p.vy-=fy; }
        });
    });
    people.forEach(p=>{
        p.vx *= 0.85;
        p.vy *= 0.85;
        p.x += p.vx;
        p.y += p.vy;
    });

    nodeElems.forEach(n=>{
        n.g.setAttribute("transform",`translate(${n.p.x},${n.p.y})`);
    });
    linkElems.forEach(l=>{
        l.line.setAttribute("x1",l.from.x);
        l.line.setAttribute("y1",l.from.y);
        l.line.setAttribute("x2",l.to.x);
        l.line.setAttribute("y2",l.to.y);
    });
}

// drag function for both mouse and touch
function makeDraggable(element, person){
    let offsetX=0, offsetY=0, dragging=false;

    // mouse events
    element.addEventListener("mousedown", e=>{
        dragging=true;
        offsetX=e.clientX-person.x;
        offsetY=e.clientY-person.y;
        svg.style.cursor="grabbing";
    });
    window.addEventListener("mousemove", e=>{
        if(!dragging) return;
        person.x=e.clientX-offsetX;
        person.y=e.clientY-offsetY;
    });
    window.addEventListener("mouseup", e=>{
        dragging=false;
        svg.style.cursor="grab";
    });

    // touch events
    element.addEventListener("touchstart", e=>{
        dragging=true;
        const touch = e.touches[0];
        offsetX=touch.clientX-person.x;
        offsetY=touch.clientY-person.y;
        svg.style.cursor="grabbing";
        e.preventDefault();
    }, {passive:false});

    window.addEventListener("touchmove", e=>{
        if(!dragging) return;
        const touch = e.touches[0];
        person.x=touch.clientX-offsetX;
        person.y=touch.clientY-offsetY;
        e.preventDefault();
    }, {passive:false});

    window.addEventListener("touchend", e=>{
        dragging=false;
        svg.style.cursor="grab";
        e.preventDefault();
    });
}

// animate
function tick(){
    update();
    requestAnimationFrame(tick);
}
tick();
</script>
</body>
</html>
